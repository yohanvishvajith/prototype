<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Miller - Sri Lanka Rice Supply Chain</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />
  </head>
  <body>
    <header class="site-header">
      <h1 class="site-title">Miller Dashboard</h1>
      <nav class="tabs" aria-label="Miller tabs">
        <ul>
          <li class="tab active"><a href="#" data-index="0">Purchases</a></li>
          <li class="tab"><a href="#" data-index="1">Milling</a></li>
          <li class="tab"><a href="#" data-index="2">Damage</a></li>
          <li class="tab"><a href="#" data-index="3">History</a></li>
        </ul>
      </nav>
    </header>

    <main class="content">
      <section class="panel" id="purchases-panel">
        <h2>Record Purchase</h2>

        <div class="card">
          <form id="purchaseForm">
            <label for="purchaseFromType">Purchase From</label>
            <select id="purchaseFromType" required>
              <option value="Farmer">Farmer</option>
              <option value="Broker">Broker</option>
            </select>

            <label for="sourceSelect">Source</label>
            <select id="sourceSelect" required>
              <option value="">Loading...</option>
            </select>

            <label for="paddyType">Paddy Type</label>
            <select id="paddyType" required>
              <option value="">Select paddy type</option>
              <option value="Samba">Samba</option>
              <option value="Nadu">Nadu</option>
              <option value="Keeri Samba">Keeri Samba</option>
              <option value="Other">Other</option>
            </select>

            <label for="qty">Quantity (kg)</label>
            <input id="qty" type="number" min="0" step="0.01" required />

            <div class="modal-actions">
              <button type="submit" class="btn primary">Save Purchase</button>
              <a href="/" class="btn">Back to home</a>
            </div>
          </form>
        </div>

        <h3 style="margin-top: 18px">Recent Purchases</h3>
        <div class="table-wrap">
          <table class="data-table" id="purchasesTable">
            <thead>
              <tr>
                <th>When</th>
                <th>From (type)</th>
                <th>Source</th>
                <th>Paddy Type</th>
                <th>Qty (kg)</th>
                <th>Block ID</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="panel" id="milling-panel" hidden>
        <h2>Milling Process</h2>

        <div class="card">
          <form id="millingForm">
            <label for="millingPaddyType">Paddy Type</label>
            <select id="millingPaddyType" required>
              <option value="">Select paddy type</option>
            </select>

            <label for="millingInputQty">Input Paddy Quantity (kg)</label>
            <input
              id="millingInputQty"
              type="number"
              min="0"
              step="0.01"
              required
            />

            <label for="millingOutputQty">Output Rice Quantity (kg)</label>
            <input
              id="millingOutputQty"
              type="number"
              min="0"
              step="0.01"
              required
            />

            <label for="millingDate">Milling Date</label>
            <input id="millingDate" type="date" required />

            <div class="modal-actions">
              <button type="submit" class="btn primary">Record Milling</button>
            </div>
          </form>
        </div>

        <h3 style="margin-top: 18px">Recent Milling Records</h3>
        <div class="table-wrap">
          <table class="data-table" id="millingTable">
            <thead>
              <tr>
                <th>Date</th>
                <th>Paddy Type</th>
                <th>Input (kg)</th>
                <th>Output Rice (kg)</th>
                <th>Yield (%)</th>
                <th>Block ID</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="panel" id="damage-panel" hidden>
        <h2>Record Damage</h2>

        <div class="card">
          <form id="damageForm">
            <label for="damagePaddyType">Paddy Type</label>
            <select id="damagePaddyType" required>
              <option value="">Select paddy type</option>
              <option value="Samba">Samba</option>
              <option value="Nadu">Nadu</option>
              <option value="Keeri Samba">Keeri Samba</option>
              <option value="Other">Other</option>
            </select>

            <label for="damageQty">Damaged Quantity (kg)</label>
            <input id="damageQty" type="number" min="0" step="0.01" required />

            <label for="damageReason">Reason</label>
            <textarea
              id="damageReason"
              rows="3"
              placeholder="Describe the reason for damage"
              required
            ></textarea>

            <div class="modal-actions">
              <button type="submit" class="btn primary">Record Damage</button>
            </div>
          </form>
        </div>

        <h3 style="margin-top: 18px">Recent Damages</h3>
        <div class="tabs" style="margin-bottom: 12px">
          <ul
            style="
              display: flex;
              gap: 8px;
              list-style: none;
              padding: 0;
              margin: 0;
            "
          >
            <li>
              <button id="damagePaddyTab" class="btn primary">Paddy</button>
            </li>
            <li><button id="damageRiceTab" class="btn">Rice</button></li>
          </ul>
        </div>

        <div class="table-wrap" id="damagesPaddyPanel">
          <table class="data-table" id="damagesPaddyTable">
            <thead>
              <tr>
                <th>Date</th>
                <th>Paddy Type</th>
                <th>Qty (kg)</th>
                <th>Reason</th>
                <th>Block ID</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="table-wrap" id="damagesRicePanel" hidden>
          <table class="data-table" id="damagesRiceTable">
            <thead>
              <tr>
                <th>Date</th>
                <th>Rice Type</th>
                <th>Qty (kg)</th>
                <th>Reason</th>
                <th>Block ID</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="panel" id="history-panel" hidden>
        <div style="display: flex; gap: 10px; margin-bottom: 20px">
          <button
            id="historyTransactionBtn"
            class="btn primary"
            style="flex: 1"
          >
            Transaction
          </button>
          <button id="historyMillingBtn" class="btn" style="flex: 1">
            Milling
          </button>
        </div>

        <div id="historyTransactionPanel">
          <h3>Purchases History</h3>
          <div class="table-wrap">
            <table class="data-table" id="historyTable">
              <thead>
                <tr>
                  <th>When</th>
                  <th>From (type)</th>
                  <th>Source</th>
                  <th>Paddy Type</th>
                  <th>Qty (kg)</th>
                  <th>Block ID</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

        <div id="historyMillingPanel" hidden>
          <h3>Milling History</h3>
          <div class="table-wrap">
            <table class="data-table" id="historyMillingTable">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Paddy Type</th>
                  <th>Input Paddy (kg)</th>
                  <th>Output Rice (kg)</th>
                  <th>Yield (%)</th>
                  <th>Block ID</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </section>
    </main>

    <script>
      // Miller purchases UI (server-backed). Fetches /api/users and /api/transactions.
      let users = [];
      let purchases = [];
      let currentUser = null;

      function qs(sel) {
        return document.querySelector(sel);
      }

      // Fetch users for a specific type from the server endpoint
      async function fetchUsersByType(type) {
        try {
          const q = encodeURIComponent(type || "");
          const res = await fetch(`/api/users/by_type?type=${q}`);
          if (!res.ok) throw new Error("Failed to load users by type");
          const data = await res.json();
          return Array.isArray(data) ? data : [];
        } catch (e) {
          console.error("Could not fetch users by type:", e);
          return [];
        }
      }

      async function fetchCurrentUser() {
        try {
          const res = await fetch("/api/me");
          if (!res.ok) return null;
          const j = await res.json();
          return j && j.ok ? j : null;
        } catch (e) {
          console.error("Could not fetch current user", e);
          return null;
        }
      }

      function userTypeOf(u) {
        return u.user_type || u.type || u.role || u.userType || "";
      }
      function userLabel(u) {
        return (
          (u.full_name || u.name || "") +
          " (" +
          (u.user_code || u.code || u.id || "") +
          ")"
        );
      }

      // Fetch paddy types from server
      async function fetchPaddyTypes() {
        try {
          const res = await fetch("/api/paddy_types");
          if (!res.ok) throw new Error("Failed to load paddy types");
          const data = await res.json();
          return Array.isArray(data) ? data : [];
        } catch (e) {
          console.error("Could not fetch paddy types:", e);
          return [];
        }
      }

      async function populateSourceSelect(fromType) {
        const sel = qs("#sourceSelect");
        sel.innerHTML = "";

        // If purchasing from a broker, the actual sources are collecters
        // so map Broker -> Collecter when querying the backend.
        let queryType = fromType;
        if ((fromType || "").toLowerCase() === "broker") {
          queryType = "Collecter";
        }

        const list = await fetchUsersByType(queryType);

        if (!list || list.length === 0) {
          const opt = document.createElement("option");
          opt.value = "";
          // show friendly message using the UI label (fromType)
          opt.textContent = "No " + (fromType || "items") + " found";
          sel.appendChild(opt);
          return;
        }

        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select " + (queryType || fromType);
        sel.appendChild(placeholder);
        list.forEach((u) => {
          const o = document.createElement("option");
          o.value = u.id || u.user_code || "";
          o.textContent =
            (u.full_name || "") + " (" + (u.user_code || u.id || "") + ")";
          o.dataset.full = u.full_name || "";
          sel.appendChild(o);
        });
      }

      // Load transactions for the current user from the server
      async function loadServerTransactions() {
        if (!currentUser) return;
        try {
          const res = await fetch(
            `/api/transactions?to=${encodeURIComponent(currentUser.user_id)}`
          );
          if (!res.ok) throw new Error("Failed to load transactions");
          const rows = await res.json();
          // map server rows to UI records
          purchases = rows.map((r) => ({
            id: "srv-" + r.id,
            when: r.datetime || r.created_at,
            fromType: "",
            sourceId: r["from"],
            sourceName: String(r["from"]),
            paddyType: r.type || "",
            qty: Number(r.quantity) || 0,
            tx_id: r.id,
            block_hash: r.block_hash || null,
          }));
        } catch (e) {
          console.error("Could not load server transactions", e);
          purchases = [];
        }
      }

      function renderTables() {
        const pBody = qs("#purchasesTable tbody");
        const hBody = qs("#historyTable tbody");
        pBody.innerHTML = "";
        hBody.innerHTML = "";

        const recent = purchases.slice().reverse().slice(0, 10);
        recent.forEach((r) => {
          const tr = document.createElement("tr");
          const hashDisplay = r.block_hash
            ? String(r.block_hash).slice(0, 12) + "..."
            : "Not available";
          tr.innerHTML = `<td>${new Date(r.when).toLocaleString()}</td><td>${
            r.fromType
          }</td><td>${r.sourceName}</td><td>${r.paddyType}</td><td>${
            r.qty
          }</td><td>${hashDisplay}</td>`;
          pBody.appendChild(tr);
        });

        purchases
          .slice()
          .reverse()
          .forEach((r) => {
            const tr = document.createElement("tr");
            const hashDisplay = r.block_hash
              ? String(r.block_hash).slice(0, 12) + "..."
              : "Not available";
            tr.innerHTML = `<td>${new Date(r.when).toLocaleString()}</td><td>${
              r.fromType
            }</td><td>${r.sourceName}</td><td>${r.paddyType}</td><td>${
              r.qty
            }</td><td>${hashDisplay}</td>`;
            hBody.appendChild(tr);
          });
      }

      function setupTabs() {
        const tabs = Array.from(document.querySelectorAll(".tabs .tab"));
        const panels = [
          qs("#purchases-panel"),
          qs("#milling-panel"),
          qs("#damage-panel"),
          qs("#history-panel"),
        ];
        tabs.forEach((tab, i) => {
          tab.addEventListener("click", (ev) => {
            ev.preventDefault();
            tabs.forEach((t) => t.classList.remove("active"));
            tab.classList.add("active");
            panels.forEach((p) => (p.hidden = true));
            panels[i].hidden = false;
          });
        });
      }

      function setupHistoryTabs() {
        const transactionBtn = qs("#historyTransactionBtn");
        const millingBtn = qs("#historyMillingBtn");
        const transactionPanel = qs("#historyTransactionPanel");
        const millingPanel = qs("#historyMillingPanel");

        transactionBtn.addEventListener("click", () => {
          transactionBtn.classList.add("primary");
          millingBtn.classList.remove("primary");
          transactionPanel.hidden = false;
          millingPanel.hidden = true;
        });

        millingBtn.addEventListener("click", () => {
          millingBtn.classList.add("primary");
          transactionBtn.classList.remove("primary");
          millingPanel.hidden = false;
          transactionPanel.hidden = true;
          renderHistoryMillingTable();
        });
      }

      async function renderHistoryMillingTable() {
        const mBody = qs("#historyMillingTable tbody");
        mBody.innerHTML = "";
        try {
          const millerId = currentUser ? currentUser.user_id : null;
          const url = millerId
            ? `/api/milling?miller_id=${encodeURIComponent(millerId)}`
            : "/api/milling";
          const res = await fetch(url);
          if (!res.ok) throw new Error("Failed to load milling records");
          const millingRecords = await res.json();
          millingRecords.forEach((r) => {
            const inputQty = parseFloat(r.input_paddy) || 0;
            const outputQty = parseFloat(r.output_rice) || 0;
            const yield_percent =
              inputQty > 0 ? ((outputQty / inputQty) * 100).toFixed(2) : 0;
            const hashDisplay = r.block_hash
              ? String(r.block_hash).slice(0, 12) + "..."
              : "Not available";
            const tr = document.createElement("tr");
            const displayDate = r.milling_date || r.created_at;
            tr.innerHTML = `<td>${new Date(
              displayDate
            ).toLocaleDateString()}</td>
                          <td>${r.paddy_type}</td>
                          <td>${inputQty.toFixed(2)}</td>
                          <td>${outputQty.toFixed(2)}</td>
                          <td>${yield_percent}%</td>
                          <td>${hashDisplay}</td>`;
            mBody.appendChild(tr);
          });
        } catch (e) {
          console.error("Could not load milling records:", e);
        }
      }

      async function init() {
        setupTabs();
        setupHistoryTabs();
        // load current user then load server transactions
        // get logged-in user from server-side session
        const me = await fetchCurrentUser();
        if (!me) {
          window.location = "/";
          return;
        }
        currentUser = me;
        // For debugging: print current user to console when a Miller logs in
        try {
          if (
            currentUser &&
            (currentUser.user_type || "").toLowerCase().startsWith("miller")
          ) {
            console.log("Current user (miller):", currentUser);
          } else {
            console.log("Current user:", currentUser);
          }
        } catch (e) {
          console.log("Current user (raw):", currentUser);
        }
        const fromSel = qs("#purchaseFromType");
        await populateSourceSelect(fromSel.value);
        // populate paddy types
        const types = await fetchPaddyTypes();
        const pSel = qs("#paddyType");
        pSel.innerHTML = "";
        const ph = document.createElement("option");
        ph.value = "";
        ph.textContent = "Select paddy type";
        pSel.appendChild(ph);
        types.forEach((t) => {
          const o = document.createElement("option");
          o.value = t.name || t.id || "";
          o.textContent = t.name || String(t.id || "");
          pSel.appendChild(o);
        });
        await loadServerTransactions();
        renderTables();
        fromSel.addEventListener("change", (e) =>
          populateSourceSelect(e.target.value)
        );

        // Populate milling paddy type dropdown
        const millingPaddyTypeSel = qs("#millingPaddyType");
        millingPaddyTypeSel.innerHTML = "";
        const millingPh = document.createElement("option");
        millingPh.value = "";
        millingPh.textContent = "Select paddy type";
        millingPaddyTypeSel.appendChild(millingPh);
        types.forEach((t) => {
          const o = document.createElement("option");
          o.value = t.name || t.id || "";
          o.textContent = t.name || String(t.id || "");
          millingPaddyTypeSel.appendChild(o);
        });

        // Set default milling date to today
        const today = new Date().toISOString().split("T")[0];
        qs("#millingDate").value = today;

        qs("#purchaseForm").addEventListener("submit", (ev) => {
          ev.preventDefault();
          const fromType = qs("#purchaseFromType").value;
          const srcSel = qs("#sourceSelect");
          const sourceId = srcSel.value;
          const sourceName = srcSel.selectedOptions[0]
            ? srcSel.selectedOptions[0].textContent
            : "";
          const paddyType = qs("#paddyType").value;
          const qty = qs("#qty").value;
          if (!sourceId || !paddyType || !qty) {
            alert("Please fill all fields");
            return;
          }
          const rec = {
            id:
              Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
            when: new Date().toISOString(),
            fromType,
            sourceId,
            sourceName,
            paddyType,
            qty: Number(qty),
            to: currentUser ? currentUser.user_id : null,
          };

          // POST the transaction to the server
          (async () => {
            try {
              const payload = {
                from: rec.sourceId,
                to: rec.to,
                type: rec.paddyType,
                quantity: rec.qty,
                datetime: rec.when,
              };
              const resp = await fetch("/api/transactions", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              });
              const j = await resp.json().catch(() => ({}));
              if (!resp.ok) {
                alert(
                  "Failed to save transaction: " + (j.error || resp.statusText)
                );
                return;
              }
              // on success, reload server transactions to reflect DB
              await loadServerTransactions();
              renderTables();
              qs("#purchaseForm").reset();
              populateSourceSelect(fromType);
            } catch (err) {
              console.error("Error saving transaction", err);
              alert("Error saving transaction");
            }
          })();
        });

        renderTables();

        // Damage form handler
        qs("#damageForm").addEventListener("submit", (ev) => {
          ev.preventDefault();
          const paddyType = qs("#damagePaddyType").value;
          const qty = qs("#damageQty").value;
          const reason = qs("#damageReason").value;
          if (!paddyType || !qty || !reason) {
            alert("Please fill all fields");
            return;
          }

          // POST the damage to the server
          (async () => {
            try {
              const kind = qs("#damageRiceTab").classList.contains("primary")
                ? "rice"
                : "paddy";
              const payload = {
                user_id: currentUser ? currentUser.user_id : null,
                paddy_type: paddyType,
                quantity: qty,
                reason: reason,
                damage_date: new Date().toISOString(),
                kind: kind,
              };
              const resp = await fetch("/api/damages", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              });
              const j = await resp.json().catch(() => ({}));
              if (!resp.ok) {
                alert(
                  "Failed to record damage: " + (j.error || resp.statusText)
                );
                return;
              }
              // refresh paddy damage table from server
              await renderPaddyDamageTable();
              qs("#damageForm").reset();
              alert("Damage recorded successfully");
            } catch (err) {
              console.error("Error recording damage", err);
              alert("Error recording damage");
            }
          })();
        });

        setupDamageTabs();
        await renderPaddyDamageTable();
        renderMillingTable();

        // Milling form handler
        qs("#millingForm").addEventListener("submit", (ev) => {
          ev.preventDefault();
          const paddyType = qs("#millingPaddyType").value;
          const inputQty = qs("#millingInputQty").value;
          const outputQty = qs("#millingOutputQty").value;
          const millingDate = qs("#millingDate").value;

          if (!paddyType || !inputQty || !outputQty || !millingDate) {
            alert("Please fill all fields");
            return;
          }

          const inputNum = parseFloat(inputQty);
          const outputNum = parseFloat(outputQty);

          if (outputNum > inputNum) {
            alert("Output rice quantity cannot exceed input paddy quantity");
            return;
          }

          // POST the milling record to the server
          (async () => {
            try {
              const payload = {
                miller_id: currentUser ? currentUser.user_id : null,
                paddy_type: paddyType,
                input_paddy: inputNum,
                output_rice: outputNum,
                milling_date: millingDate,
              };
              const resp = await fetch("/api/milling", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              });
              const j = await resp.json().catch(() => ({}));
              if (!resp.ok) {
                alert(
                  "Failed to save milling record: " +
                    (j.error || resp.statusText)
                );
                return;
              }
              // refresh from server
              await renderMillingTable();
              qs("#millingForm").reset();
              const today = new Date().toISOString().split("T")[0];
              qs("#millingDate").value = today;
              alert("Milling record saved successfully");
            } catch (err) {
              console.error("Error saving milling record", err);
              alert("Error saving milling record");
            }
          })();
        });
      }

      async function renderMillingTable() {
        const mBody = qs("#millingTable tbody");
        mBody.innerHTML = "";
        try {
          const millerId = currentUser ? currentUser.user_id : null;
          const url = millerId
            ? `/api/milling?miller_id=${encodeURIComponent(millerId)}`
            : "/api/milling";
          const res = await fetch(url);
          if (!res.ok) throw new Error("Failed to load milling records");
          const millingRecords = await res.json();
          millingRecords.forEach((r) => {
            const inputQty = parseFloat(r.input_paddy) || 0;
            const outputQty = parseFloat(r.output_rice) || 0;
            const yield_percent =
              inputQty > 0 ? ((outputQty / inputQty) * 100).toFixed(2) : 0;
            const hashDisplay = r.block_hash
              ? String(r.block_hash).slice(0, 12) + "..."
              : "Not available";
            const tr = document.createElement("tr");
            const displayDate = r.milling_date || r.created_at;
            tr.innerHTML = `<td>${new Date(
              displayDate
            ).toLocaleDateString()}</td>
                          <td>${r.paddy_type}</td>
                          <td>${inputQty.toFixed(2)}</td>
                          <td>${outputQty.toFixed(2)}</td>
                          <td>${yield_percent}%</td>
                          <td>${hashDisplay}</td>`;
            mBody.appendChild(tr);
          });
        } catch (e) {
          console.error("Could not load milling records:", e);
        }
      }

      async function renderPaddyDamageTable() {
        const dBody = qs("#damagesPaddyTable tbody");
        dBody.innerHTML = "";
        try {
          const userId = currentUser ? currentUser.user_id : null;
          const url = userId
            ? `/api/damages?user_id=${encodeURIComponent(userId)}&kind=paddy`
            : "/api/damages?kind=paddy";
          const res = await fetch(url);
          if (!res.ok) throw new Error("Failed to load paddy damages");
          const damages = await res.json();
          damages.forEach((d) => {
            const tr = document.createElement("tr");
            const displayDate = d.damage_date || d.created_at;
            const hashDisplay = d.block_hash
              ? String(d.block_hash).slice(0, 12) + "..."
              : "Not available";
            tr.innerHTML = `<td>${new Date(displayDate).toLocaleString()}</td>
                          <td>${d.paddy_type}</td>
                          <td>${d.quantity}</td>
                          <td>${d.reason}</td>
                          <td title="${
                            d.block_hash || ""
                          }">${hashDisplay}</td>`;
            dBody.appendChild(tr);
          });
        } catch (e) {
          console.error("Could not load paddy damages:", e);
        }
      }

      async function renderRiceDamageTable() {
        const dBody = qs("#damagesRiceTable tbody");
        dBody.innerHTML = "";
        try {
          const userId = currentUser ? currentUser.user_id : null;
          const url = userId
            ? `/api/damages?user_id=${encodeURIComponent(userId)}&kind=rice`
            : "/api/damages?kind=rice";
          const res = await fetch(url);
          if (!res.ok) throw new Error("Failed to load rice damages");
          const damages = await res.json();
          damages.forEach((d) => {
            const tr = document.createElement("tr");
            const displayDate = d.damage_date || d.created_at;
            const hashDisplay = d.block_hash
              ? String(d.block_hash).slice(0, 12) + "..."
              : "Not available";
            tr.innerHTML = `<td>${new Date(
              displayDate
            ).toLocaleDateString()}</td>
                          <td>${d.paddy_type || d.rice_type}</td>
                          <td>${d.quantity}</td>
                          <td>${d.reason}</td>
                          <td title="${
                            d.block_hash || ""
                          }">${hashDisplay}</td>`;
            dBody.appendChild(tr);
          });
        } catch (e) {
          console.error("Could not load rice damages:", e);
        }
      }

      function setupDamageTabs() {
        const pTab = qs("#damagePaddyTab");
        const rTab = qs("#damageRiceTab");
        const pPanel = qs("#damagesPaddyPanel");
        const rPanel = qs("#damagesRicePanel");

        pTab.addEventListener("click", async () => {
          pTab.classList.add("primary");
          rTab.classList.remove("primary");
          pPanel.hidden = false;
          rPanel.hidden = true;
          await renderPaddyDamageTable();
        });

        rTab.addEventListener("click", async () => {
          rTab.classList.add("primary");
          pTab.classList.remove("primary");
          rPanel.hidden = false;
          pPanel.hidden = true;
          await renderRiceDamageTable();
        });
      }

      window.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
